"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};let PRTLEV=5;
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = __importDefault(require("events"));
const isomorphic_ws_1 = __importDefault(require("isomorphic-ws"));// can be ws ?
const defaultOptions = {// UUHH nb defaultOptions.ws is the factory of the connected ws obj returning : require("isomorphic-ws")(ws://localhost:port/path)
    protocol: 'ws',
    host: 'localhost',
    port: 8123,
    path: '/api/websocket',
    messageSerializer: (outgoingMessage) => JSON.stringify(outgoingMessage),
    messageParser: (incomingMessage) => JSON.parse(incomingMessage.data),
    // A method that returns a websocket instance. Can be overriden to use a custom behavior:
    ws: (opts) => {// the ws "ws" obj like  ws = new WebSocket('ws://www.host.com/path'); . really the func ws returns ws() , the websocket conn obj : new require("isomorphic-ws")(ws://localhost:port/path)
        return new isomorphic_ws_1.default(`${opts.protocol}://${opts.host}:${opts.port}${opts.path}`);
        /*
        Sending and receiving text data

            import WebSocket from 'ws';

            const ws = new WebSocket('ws://www.host.com/path');

            ws.on('error', console.error);

            ws.on('open', function open() {
            ws.send('something');
            });

            ws.on('message', function message(data) {
            console.log('received: %s', data);
            });
        */
    },
};
const command = async (commandArgs, client) => {// the command sent to ha 
    return new Promise((resolve, reject) => {
        const id = client.seq;
        client.resultMap[id] = (resultMessage) => {// fill bank of cmdid cb with this cb to resolve the promise with resultMessage.result. // command cb LLII
            if (resultMessage.success)
                resolve(resultMessage.result);// resolves command wth result data. nb 
                                            //  call_service : result={context:{id,parent_id,user_id},response:null} useless !
                                            //  fire_event   : result={context:{id,parent_id,user_id}}
            else
                reject(new Error(resultMessage.error.message));
            // We won't need this callback again once we use it:
            delete client.resultMap[id];
        };
        let sending=client.options.messageSerializer(Object.assign(Object.assign({}, commandArgs), { id }));
        // console.error(' send (command): ',sending);console.log(' send (command): ',sending);
        if(PRTLEV>5)console.log(' ha ws callService sending ws ctl command to ha websocket api: ',sending);

        client.ws.send(sending);// ws.send('something');
                                                                                                    /* ex1: .send( jsonof: {
                                                                                                                            type: 'call_service',
                                                                                                                            domain,
                                                                                                                            service,
                                                                                                                            service_data: { entity_id: reads[2]},
                                                                                                                            id
                                                                                                                              }

                                                                                                                                    */
        // Increment the shared message id sequence:
        client.seq++;
    });
};
const binaryResultTransform = (result) => {
    return {
        content_type: result.content_type,
        content: Buffer.from(result.content, 'base64'),
    };
};
const messageHandler = (client) => {// emit the received message in the emitter obj, so these events can be handled by emitter subscribed listener
    return (wsMessage) => {
        const message = client.options.messageParser(wsMessage);
        // Emit an event for any message under a main 'message' listener:
        client.emitter.emit('message', message);
        // Emit an event for any message of any type:
        if (message.type)
            client.emitter.emit(message.type, message);
        // Emit an event for event-type messages:
        if (message.type === 'event' && message.event.event_type) {
            client.emitter.emit(message.event.event_type, message.event);
        }
        // If this is a result message, match it with the results map on the client
        // and call the matching function:
        if (message.id && message.type === 'result') {
            if (typeof client.resultMap[message.id] !== 'undefined') {
                client.resultMap[message.id](message);// command cb LLII
            }
        }
    };
};
const clientObject = (client) => {// the ha function available on ws api . 
                                    
    return {// is the resolution of createClient(callerOptions = 
            //  { rawclient=client={ seq: 1, options, resultMap: {}, emitter: ws: options.ws(options)},
            //    getStates,getServices,getPanel,getConfig,on,callService,fireEvent,,, }
        rawClient: client,/*
                             = {
                                seq: 1,
                                options,
                                resultMap: {},
                                emitter: new events_1.default(),
                                ws: options.ws(options),// =  defaultOptions.ws(options), the "isomorphic-ws" ws 
                                };
                        */
        getStates: async () => command({ type: 'get_states' }, client),// 
        getServices: async () => command({ type: 'get_services' }, client),
        getPanels: async () => command({ type: 'get_panels' }, client),
        getConfig: async () => command({ type: 'get_config' }, client),
        on: (eventId, cb) => {// the std ws.on('eventid',handler) can be called with client.on('eventid',handler) ? in "isomorphic-ws"   use client.emitter.on() for ws.on() !
                                // client.on will set the cb handler for the event in emitter obj. 
                                // nb in AAWWW we subscribed to receive all events, here we set the handler for specific event ex state_changed 
                                //      so when we receive the event emitted we will look for subscribed (.on() ) event looking at their  type , ex: "state_changed", 
 
 
            client.emitter.on(eventId, cb);
        },

        async callService(domain, service, additionalArgs = {},target) {// ex1: client.callService('switch','turn_on','switch.rssi')
            //         >>  command(commandArgs, client)
            let call_service={// will call  commandArgs
            type: 'call_service',
            domain,
            service,
            service_data: additionalArgs
            };
            if(target)call_service.target=target;
            return command(call_service, client);// use the client var in closure . could use also this.rawClient !
            },
        // added :
        async fireEvent(event_type, additionalArgs = {}) {// ?? ex1: client.callService('switch','turn_on','switch.rssi')
            //         >>  command(commandArgs, client)
            return command({// will call  commandArgs
            type: 'fire_event',
            event_type,
            event_data: additionalArgs,
            }, client);
            },


        async getMediaPlayerThumbnail(entityId) {
            return command({
                type: 'media_player_thumbnail',
                entity_id: entityId,
            }, client).then(binaryResultTransform);
        },
        async getCameraThumbnail(entityId) {
            return command({
                type: 'camera_thumbnail',
                entity_id: entityId,
            }, client).then(binaryResultTransform);
        },
    };
};
const connectAndAuthorize = async (client, resolveWith) => {// returns a promise resolving with clientObject(client) when command AAWW resolve
    return new Promise((resolve, reject) => {// the connectAndAuthorize() promise
        client.ws.onmessage = messageHandler(client);// incoming message handler is messageHandler() func working on closure client obj
        client.ws.onerror = (err) => {
            // Unlikely for a listener to exist at this stage, but just in case:
            client.emitter.emit('ws_error', err);
            reject(err);
        };
        // Pass-through onclose events to the client: // ws onclose event is handled by emit.on(ws_close,) handler
        client.ws.onclose = (event) => client.emitter.emit('ws_close', event);// similar to client.on('close',handler)
        client.emitter.on('auth_ok', () => {
            // Immediately subscribe to all events, and return the client handle:
            command({ type: 'subscribe_events' }, client)// AAWWW subscribe to all events, no command result data, 
                                                        //   receiving events (same id=AAA of this cmd) we look the event type in event.event_type="state_changed",
                                                        //      so according with .on requested we pass related event to .on handlers ex: .on('state_change',,)
                                                        //   nb subscribing trigger we'll receve related event (same id of trigger cmd)  with event.variablestrigger ....
                                                        //      question , that event we'll be fires also as std event ( id = AAA)
                .then(() => resolve(resolveWith))
                .catch((err) => reject(err));
        });
        client.emitter.on('auth_invalid', (msg) => reject(new Error(msg.message)));
        client.emitter.on('auth_required', () => {
            // If auth is required, immediately reject the promise if no token was provided:
            if (!client.options.token) {
                reject(new Error('Homeassistant requires authentication, but token not provided in options'));
            }
            client.ws.send(client.options.messageSerializer({//   ws.send('something'); pimo messaggio chiedente auth 
                type: 'auth',
                access_token: client.options.token,
            }));
        });
    });
};
async function createClient(callerOptions = {},PRTLEV_=2) {// LLHH : return  connectAndAuthorize() promise, will resolve with clientObject(client) when command AAWW resolve (receive answer)
    const options = Object.assign(Object.assign({}, defaultOptions), callerOptions);// = { protocol,host,port,path, messageSerializer,messageParser,ws=wsfactory ,  token,host, port}
    if(PRTLEV>5)console.log(` HA WS API:  creating ws connection to ha : host:${callerOptions.host}`)  ;                                                                                                        // ws(options) will returns  : new require("isomorphic-ws")(ws://localhost:port/path): 
    const client = {PRTLEV:PRTLEV_,
        seq: 1,
        options,
        resultMap: {},
        emitter: new events_1.default(),
        ws: options.ws(options),// =  defaultOptions.ws(options) ; options.ws is the ws ctl factory
                                // see  UUHH : 
                                // nb defaultOptions.ws is the factory of the connected ws obj returning : require("isomorphic-ws")(ws://localhost:port/path)
    };
    return connectAndAuthorize(client, clientObject(client));// LLHH resolve with clientObject(client)
}
// exports.default = createClient;
module.exports =createClient;
