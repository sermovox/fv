/*
fc.prototype.readSync  =//  return the promise DDEERR resolving 0/1 or null if reject
 () {
    return getgpio(this.cl);
    async function getgpio(clas){//  returns DDEERR=rread(true), the readSync returned promise .



                                        // ****   MNG SUMMARY  sunto 113052023
                                        // - chiamo rread ricursivamente , rread :
                                        	- recupera il messaggio re :
                                        		- solo la prima volta  (solo al primo  iterazione di rread() : checkQueueFirst=true) 
                                        			> il last in current queue 
                                        			(a meno che non ci sia per un dev var 'ctlpresent')
                                        			 get last entry in that.status[gpio] queue array, leave in array only last msg 
                                        		e poi 
                                        		- il valore re=await ( stList()=promise XXTT ) ,  di un futuro msg processato da theListener(lastmsg, test = 0) in input processing 
                                        			  re sarà la risoluzione del promise XXTT che avviene tramite 
                                        			  	la chiamata fatta in msg income processing  di  theListener=mqttInst.statusList[dev][i]:
                                                                  		theListener(msg,test=0) : tornerà in msg processing :
                                                                  			- la promise DDEERR1 quando !fired,  al primo call di theListener con un messaggio 
				                                                  		     la promise DDEERR1 verra risolta chiamando:  resRetList(resetListener=true/false);
				                                                  		     	resetListener:
				                                    					      true > quando ... , say to message income code to reset (riproporre )the listener perche 
				                                    					      				il msg non va bene : MMJJUU
				                                    					      false > quando ......   ex in ending
				                                    			- return undef se fired , cioe alle successive chiamate di theListener /messaggi  ??  
				                                    			- return id se test=1 
				                                    			
				                                    		theListener (msg,test=0) will
				                                    			- alla prima chiamata  (fired=false:
				                                    				res(lastmsg);// risolvo con il msg XXTT che lo assegna a re
				                                    				 return the promise retProm = DDEERR1 
				                                    			- successivamente verra ritornato undefined ???????
				                                    					      
								 la promise XXTT :
								 	- crea/restore 	theListener,
								 	- se resetListener=false (inizio) :
								 		mqttInst.statusList[dev].push(theListener);// set for first time the listener in message incom

								 	- altrimenti risolvo DDEERR1 con true
								 	
								 		nb  resetListener viene posto =true 
								 			- prima di reiterare rread() quando si trova un re non valido (es a presence or meta command)
								 				> quindi dopo aver aggiunto theListener in statusList al prima iterazione di rread 
								 					resetListener diventa true nelle successive iterazioni ? ?
                                                                  	
                                                                  	-  setTimeout()  risolve XXTT con ''
                                                         
                                                 - in base al protocollo si estrae il valore corretto e:
                                                 
                                                 	ending(val) , se interpreto bene re 
                                                        ending(null) se non interpreto
                                                        resetListener = true;  return rread(false); se trovo un presence in msg 
                                                        
                                                        
                                                        ending(x) will:
                                                        	 resRetList(null);// risolve DDEERR1 in msg income  , no iterate listener 

								 return valCorrection(value); 

                                        quindi riassumendo 
                                        
                                        lancio readSync() che ritorna getgpio(this.cl);  che ritorna rread(true)
                                        	- rread(true) gira la prima volta e 
                                        		- recupera il re= msg in queue 
                                        		- o gira stList()  che : 
                                        		    aggiunge theListener alla lista 
                                        		    e si attende che in income process si chiami theListener 
                                        			theListener crea theLIstener lo aggiunge a mqttInst.statusList e attende che il income process lo chiami 
                                        				quando theListener è chiamato  
                                        				- risolve con msg il XXTT che lo assegna a re e 
                                        				- ritorna al msgincome la promice DDEERR1 
							-  esamina re: 
								-se e' ok si chiama ending(val) che 
									- resRetList(null): risolve DDEERR1 con null  in msg income  , no iterate listener 
									- risolve rread 
								- se non e' ok 
									-  resetListener = true; e reitero  return rread(false): 
										rread gira di nuovo e giro stList() che :
											risolvo DDEERR1 (messaggio precedente) con true
											e quando arrivera un msg il theListener verra ancora chiamato  :
											 theListener   che ritorna al message income undefined  (fired=true:)
											 MA NON RISOLVE XXTT ?????????


                                    retProm=new Promise(function (res,rej){// promise DDEERR1 ritornata nel receiving msg da theListener(lastmsg, test = 0)
                                                resRetList=res;});//  the resolving func reference: the cb called to resolve the promise DDEERR1 calling res()

                                    async function rread(checkQueueFirst=true)// rread è funzione iterattiva, chiama se stessa finche torna re valido 
                                                                            //      **** rread summary :
                                                                            //       si recupera re :  
                                                                                        -   ultimo valore nel queue (solo al primo  iterazione di rread() : checkQueueFirst=true)
                                                                                        	 get last entry in that.status[gpio] queue array, leave in array only last msg 
 
                                                                            //          o 
                                                                            //          - if (resetListener=false) {// def/init value:  non riproporre il listener !
                                                                                          > say to message income to set a new ( not resetted) listener to wait for next message, in request ts #', ts);
         
                                                                            //            re sarà la risoluzione del promise XXTT che avviene tramite la chiamata di 
                                                                            //            theListener: the promise XXTT  resolving function ( will call res() di XXTT
                                                                            //            viene aggiunto nel queue (mqttInst.statusList[dev].push(theListener)) dei listener che saranno chiamati quando arriva un nuovo messaggio
                                                                            //            .....un listener quando verrà chiamato da un successivo msg in incomin msg :
                                                                            //  
                                                                            //              theListener(lastmsg, test = 0):// ritorna DDEERR1 ! 
                                                                                                :
                                                                                                se fired=false (?)
                                                                                                 res(lastmsg);// resolve the waiting XXTT 
                                                                                                return retProm;// ritorna promise  DDEERR1 in incoming msg calling da theListener(msg,)
                                                                                                    sarà risolta quando chiameremo resRetList(valore risolto) in ... quando ....

                                                                                        - if (resetListener=true) {// riproporre il listener !
                                                                            //              a meno che il listener precedente fornisce un re che è valore non buono come value (un presence o altro)
                                                                            //              al che riprova iterando rread(false) e   :
                                                                                              resRetList(resetListener);//..........  
                                                                            
                                                                                                 return to message income code chiedndo to reset (riproporre )the listener perche il msg estratto dal corrente theListener bnon va bene : MMJJUU

                                        {
                                            if (checkQueueFirst && curlength > 0) 
                                            {
                                                re = mqttInst.status[gp][curlength - 1];
                                                if (re == '>ctlpresent')
                                                     return rread(false);

                                            } else {// add a listener  
                                                re = await stList(); // await the promise XXTT che si risolve dopo che in receive msg si chiama (via  mqttInst.statusList[dev]):
                                                                    //       theListener: the  promise XXTT resolving function 
                                            }


                                            // dopo aver recuperato dal queue o in un prossimo msg il valore re lo si converte ( o perchè presente in queue o perche risolto dal listener dopo un periodo secondo tipo (rele/var/probe) e protocollo 
                                            // quindi dopo un esame dello stesso :
                                            .....
                                                return ending(re);// iterazione terminata: RETURN the last queue entry o il valore risolto re !!!!!!!!!!!    
                                            ....
                                                resetListener = true;// or just add a new listener in listener queue  ,     MMJJUU
                                                return rread(false);// e relaunch rread iterately che al solito aspettera la risoluione di XXTT via theListener
                                            ...
                                            if (re == '>ctlpresent')
                                                resetListener = true;// or just add a new listener in listener queue  ,     MMJJUU
                                                return rread(false);// relaunch rread .....

                                            
                                            function stList() {//(dev,token){
                                                            // we dont have any value in queue nor a valid value. so add a listener promise that will resolve when a valid value fills the dev queue
                                                            // or reject if the waiting algo that request the readSync  cant goon 
                                                            // return the promise that  is added to the dev listener list, the promise is resolved when the listener ,is called with the next  msg
                                                            return new Promise((res, rej) => // XXTT resolved when the cb/listener is called by a following  coming msg thread. qui e' un listener di una funzionalità gia attivata 
                                                                                            // (cioe non devo chiamare un funzione e passarli il cb , giusto add un listeren in una lista che verra chiamata)


                                                                    {theListener =  // the XXTT listener promise resolving function ( will call res() : resRetList !)
                                                                        (function (id_) {   // closure , the listener resolving function factory
 
                                                                                        return function (lastmsg, test = 0) {// theListener: the  promise resolving function ( will call res()!). is sync function , so return to the caller (IIOOPP) after eventually added a new listener 


                                                                                                if (!fired) {
                                                                                                    listCall++;
                                                                                                    console.log(' stlist() : listener x dev : ', dev, ', registered to wait for next message, in request ts #', ts, ', in listener position # ', listCall, ' is called by  the message the listener was waiting for.  so cb with message: ', lastmsg);





                                                                                                    res(lastmsg);// resolve the waiting XXTT quando si chiama il listener con un prossimo msg
   
                                                                                                    fired = true;
                                                                                                    return retProm;// the returned promise in incoming msg calling theListener(msg,)
                                                                                                else return // return null  in incoming msg calling theListener(msg,)
                                                                                        })(ts)// the id 

                                                                    if (resetListener) {// riproporre il listener !
                                                                        resRetList(resetListener);// return to message income code to reset (riproporre )the listener perche il msg non va bene : MMJJUU
                                                                        console.log(' stlist() : listener x dev : ', dev, ', resolving promise, say to message income to reset the current listener that must wait for a following message, in request ts #', ts);
                                                                    } else {
                                                                        console.log(' stlist() : listener x dev : ', dev, ', say to message income to set a new ( not resetted) listener to wait for next message, in request ts #', ts);
                                                                        //in this case we were reading frm msg queue because not null . so we can just add to current listener array a new listener 
                                                                        mqttInst.statusList[dev].push(theListener);// set for first time the listener in message incom


                                                                    }
                                                                    // set the timeout :
                                                                    const myto = setTimeout(() => {
                                                                                if (resetListener) resRetList(theListener);    // better PPLLKK  
                                                                                res('');// timeout readsync result :  would be better reject ! or  null ????
                                                                                }, to);




                                         function ending(value) {
                                            resRetList(null);// no iterate listener 
                                            console.log(' ** readsync()  , using instance ', mqttInst.id, ' for portid ', gp, ', is ending . reading val: ', value, ', now current dev queue is : ', mqttInst.status[gp], ' req id ', ts, ' listener chained ', listCall);
                                            console.log(' ** readsync()  ,debug  mqttTopPub is  ', mqttInst.mqttTopPub);
                                            return valCorrection(value);
                                            }
                                        }// ends rread()
                                return rread(true);// returned by getgpio()
                                }   


    }
*/


_____________________________________________________
OLD VERSION :
/*
fc.prototype.readSync  =//  return the promise DDEERR resolving 0/1 or null if reject
 () {
    return getgpio(this.cl);
    async function getgpio(clas){//  returns DDEERR=rread(true), the readSync returned promise .



                                        // ****   MNG SUMMARY  sunto 113052023
                                        // chiamo rread ricursivamente (nel caso lo richiamo (rread) se un valore non mi soddisfa e allora lo richiedo ma senza guardare il current queue , ossia forzo un listener )
                                        // se trovo queue allora  prendo last val (a meno che non ci sia per un dev var 'ctlpresent')
                                        // altrimenti attendo la risoluzione di un listener che aggiungo alla lista 
                                        // caricamento valore letto  secondo tipo (rele/var/probe) e protocollo 
                                        // chiudo chiamando ending( valore da caricare ). nb se null significa ho letto valore erraro o nullo , sta per reject !


                                    retProm=new Promise(function (res,rej){// promise DDEERR1 ritornata nel receiving msg da theListener(lastmsg, test = 0)
                                                resRetList=res;});//  the resolving func reference: the cb called to resolve the promise DDEERR1 calling res()

                                    async function rread(checkQueueFirst=true)// rread è funzione iterattiva, chiama se stessa finche torna re valido 
                                                                            //      **** rread summary :
                                                                            //       si recupera re :  
                                                                                        -   ultimo valore nel queue (solo al primo  iterazione di rread() : checkQueueFirst=true)
                                                                            //          o 
                                                                            //          - if (resetListener=false) {// def/init value:  non riproporre il listener !
                                                                                          > say to message income to set a new ( not resetted) listener to wait for next message, in request ts #', ts);
         
                                                                            //            re sarà la risoluzione del promise XXTT che avviene tramite la chiamata di 
                                                                            //            theListener: the promise XXTT  resolving function ( will call res() di XXTT
                                                                            //            viene aggiunto nel queue (mqttInst.statusList[dev].push(theListener)) dei listener che saranno chiamati quando arriva un nuovo messaggio
                                                                            //            .....un listener quando verrà chiamato da un successivo msg in incomin msg :
                                                                            //  
                                                                            //              theListener(lastmsg, test = 0):// ritorna DDEERR1 ! 
                                                                                                :
                                                                                                se fired=false (?)
                                                                                                 res(lastmsg);// resolve the waiting XXTT 
                                                                                                return retProm;// ritorna promise  DDEERR1 in incoming msg calling da theListener(msg,)
                                                                                                    sarà risolta quando chiameremo resRetList(valore risolto) in ... quando ....

                                                                                        - if (resetListener=true) {// riproporre il listener !
                                                                            //              a meno che il listener precedente fornisce un re che è valore non buono come value (un presence o altro)
                                                                            //              al che riprova iterando rread(false) e   :
                                                                                              resRetList(resetListener);//..........  
                                                                            
                                                                                                 return to message income code chiedndo to reset (riproporre )the listener perche il msg estratto dal corrente theListener bnon va bene : MMJJUU

                                        {
                                            if (checkQueueFirst && curlength > 0) 
                                            {
                                                re = mqttInst.status[gp][curlength - 1];
                                                if (re == '>ctlpresent')
                                                     return rread(false);

                                            } else {// add a listener  
                                                re = await stList(); // await the promise XXTT che si risolve dopo che in receive msg si chiama (via  mqttInst.statusList[dev]):
                                                                    //       theListener: the  promise XXTT resolving function 
                                            }


                                            // dopo aver recuperato dal queue o in un prossimo msg il valore re lo si converte ( o perchè presente in queue o perche risolto dal listener dopo un periodo secondo tipo (rele/var/probe) e protocollo 
                                            // quindi dopo un esame dello stesso :
                                            .....
                                                return ending(re);// iterazione terminata: RETURN the last queue entry o il valore risolto re !!!!!!!!!!!    
                                            ....
                                                resetListener = true;// or just add a new listener in listener queue  ,     MMJJUU
                                                return rread(false);// e relaunch rread iterately che al solito aspettera la risoluione di XXTT via theListener
                                            ...
                                            if (re == '>ctlpresent')
                                                resetListener = true;// or just add a new listener in listener queue  ,     MMJJUU
                                                return rread(false);// relaunch rread .....

                                            
                                            function stList() {//(dev,token){
                                                            // we dont have any value in queue nor a valid value. so add a listener promise that will resolve when a valid value fills the dev queue
                                                            // or reject if the waiting algo that request the readSync  cant goon 
                                                            // return the promise that  is added to the dev listener list, the promise is resolved when the listener ,is called with the next  msg
                                                            return new Promise((res, rej) => // XXTT resolved when the cb/listener is called by a following  coming msg thread. qui e' un listener di una funzionalità gia attivata 
                                                                                            // (cioe non devo chiamare un funzione e passarli il cb , giusto add un listeren in una lista che verra chiamata)


                                                                    {theListener =  // the XXTT listener promise resolving function ( will call res() : resRetList !)
                                                                        (function (id_) {   // closure , the listener resolving function factory
 
                                                                                        return function (lastmsg, test = 0) {// theListener: the  promise resolving function ( will call res()!). is sync function , so return to the caller (IIOOPP) after eventually added a new listener 


                                                                                                if (!fired) {
                                                                                                    listCall++;
                                                                                                    console.log(' stlist() : listener x dev : ', dev, ', registered to wait for next message, in request ts #', ts, ', in listener position # ', listCall, ' is called by  the message the listener was waiting for.  so cb with message: ', lastmsg);





                                                                                                    res(lastmsg);// resolve the waiting XXTT quando si chiama il listener con un prossimo msg
   
                                                                                                    fired = true;
                                                                                                    return retProm;// the returned promise in incoming msg calling theListener(msg,)
                                                                                                else return // return null  in incoming msg calling theListener(msg,)
                                                                                        })(ts)// the id 

                                                                    if (resetListener) {// riproporre il listener !
                                                                        resRetList(resetListener);// return to message income code to reset (riproporre )the listener perche il msg non va bene : MMJJUU
                                                                        console.log(' stlist() : listener x dev : ', dev, ', resolving promise, say to message income to reset the current listener that must wait for a following message, in request ts #', ts);
                                                                    } else {
                                                                        console.log(' stlist() : listener x dev : ', dev, ', say to message income to set a new ( not resetted) listener to wait for next message, in request ts #', ts);
                                                                        //in this case we were reading frm msg queue because not null . so we can just add to current listener array a new listener 
                                                                        mqttInst.statusList[dev].push(theListener);// set for first time the listener in message incom


                                                                    }
                                                                    // set the timeout :
                                                                    const myto = setTimeout(() => {
                                                                                if (resetListener) resRetList(theListener);    // better PPLLKK  
                                                                                res('');// timeout readsync result :  would be better reject ! or  null ????
                                                                                }, to);




                                         function ending(value) {
                                            resRetList(null);// no iterate listener 
                                            console.log(' ** readsync()  , using instance ', mqttInst.id, ' for portid ', gp, ', is ending . reading val: ', value, ', now current dev queue is : ', mqttInst.status[gp], ' req id ', ts, ' listener chained ', listCall);
                                            console.log(' ** readsync()  ,debug  mqttTopPub is  ', mqttInst.mqttTopPub);
                                            return valCorrection(value);
                                            }
                                        }// ends rread()
                                return rread(true);// returned by getgpio()
                                }   


    }
*/

